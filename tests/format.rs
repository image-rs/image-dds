use dds::{header::*, *};

use util::Snapshot;

mod util;

fn short_name(channels: Channels) -> &'static str {
    match channels {
        Channels::Grayscale => "Gray",
        Channels::Alpha => "Alpha",
        Channels::Rgb => "RGB",
        Channels::Rgba => "RGBA",
    }
}

#[test]
fn supported_formats_metadata() {
    let mut table = util::PrettyTable::from_header(&[
        "Format",
        "Color",
        "bpp",
        "Header",
        "FourCC",
        "Encoding",
        "Dithering",
    ]);

    let gaps_at = [
        ("Uncompressed", Format::R8G8B8_UNORM),
        ("Subsampled", Format::R1_UNORM),
        ("Bi-planar", Format::NV12),
        ("Block Compression", Format::BC1_UNORM),
        ("ASTC", Format::ASTC_4X4_UNORM),
        ("Non-standard", Format::BC3_UNORM_RXGB),
    ];

    for &format in util::ALL_FORMATS {
        if let Some((category, _)) = gaps_at.iter().find(|(_, gap)| *gap == format) {
            table.add_empty_row();
            table
                .get_mut(0, table.height() - 1)
                .push_str(&format!("▶ ***{category}***"));
        }

        let bpp = {
            let size = 16 * 9 * 5 * 7;
            let size = Size::new(size, size);
            let bits = PixelInfo::from(format).surface_bytes(size).unwrap() * 8;
            let bpp = bits as f64 / size.pixels() as f64;
            // round to one decimal
            let bpp = (bpp * 10.0).round() / 10.0;
            if bpp == bpp.round() {
                format!("{bpp:.0}")
            } else {
                format!("{bpp:.1}")
            }
        };

        let supports_dx10 = Header::new_image(1, 1, format).to_dx10().is_some();
        let supports_dx9 = Header::new_image(1, 1, format).to_dx9().is_some();
        let dx_support = match (supports_dx9, supports_dx10) {
            (true, true) => "☑️",
            (true, false) => "DX9",
            (false, true) => "DX10",
            (false, false) => "❌",
        };

        let four_cc = if let Ok(four_cc) = FourCC::try_from(format) {
            let f = format!("{four_cc:?}");
            if let Some(short) = f.strip_prefix("FourCC(").and_then(|f| f.strip_suffix(")")) {
                short.to_string()
            } else {
                f
            }
        } else {
            "".to_string()
        };

        let (encoding, dithering) = if let Some(encoding) = format.encoding_support() {
            let mut dithering = String::new();
            if encoding.dithering() != Dithering::None {
                let possible_dithering = match format.channels() {
                    Channels::Grayscale => Dithering::Color,
                    Channels::Alpha => Dithering::Alpha,
                    Channels::Rgb => Dithering::Color,
                    Channels::Rgba => Dithering::ColorAndAlpha,
                };
                if encoding.dithering() == possible_dithering {
                    dithering += "✔️";
                } else {
                    match encoding.dithering() {
                        Dithering::Color => dithering += "Color only",
                        Dithering::Alpha => dithering += "Alpha only",
                        _ => {}
                    }
                }
            } else {
                dithering += "❌";
            }

            ("✔️".to_string(), dithering)
        } else {
            ("❌".to_string(), "".to_string())
        };

        table.add_row(&[
            format!("{format:?}"),
            format!(
                "{:5} {:?}",
                short_name(format.channels()),
                format.precision()
            ),
            bpp,
            dx_support.to_string(),
            four_cc,
            encoding,
            dithering,
        ]);
    }

    let mut output = String::new();
    let add_lines = |output: &mut String, lines: &[&str]| {
        for line in lines {
            output.push_str(line);
            output.push('\n');
        }
    };
    add_lines(&mut output,&[
        "# Supported Formats",
        "",
        "<!-- This file is generated by `tests/format.rs`. -->",
        "",
        "**Legend:**",
        "- **Format:** The name of the format.",
        "- **Color:** The native [channels](Format::channels()) and [precision](Format::precision()) of the image data.",
        "- **bpp:** Bits per pixel.",
        "- **Header:** The [header](crate::header) version(s) that supports this format (☑️ if both DX9 and DX10 support it).",
        "- **FourCC:** The FourCC code for this format, if applicable.",
        "- **Encoding:** Whether this format supports encoding.",
        "- **Dithering:** Whether encoding with [dithering](crate::EncodeOptions::dithering) is supported.",
        "",
    ]);
    table.print_markdown(&mut output);

    add_lines(&mut output, &[
        "",
        "## Formats with size requirements",
        "",
        "Certain formats can only encode images with dimensions that are multiples of a certain value. E.g. for `NV12`, both the width and height must be multiples of 2. For more information, see [`EncodingSupport::size_multiple()`].",
        "",
        "The following is a complete list of formats with size requirements. Requirements are given in the form: width multiple x height multiple.",
        "",
    ]);
    let mut size_mul_table = util::PrettyTable::from_header(&["Format", "Size Multiple"]);
    for &format in util::ALL_FORMATS {
        if let Some((w, h)) = format.encoding_support().and_then(|s| s.size_multiple()) {
            size_mul_table.add_row(&[format!("{format:?}"), format!("{w}x{h}")]);
        }
    }
    size_mul_table.print_markdown(&mut output);

    util::TextSnapshot.assert(
        &util::test_data_dir().join("../supported-formats.md"),
        &output,
    );
}

#[test]
fn format_metadata_snapshot() {
    let mut yml = String::new();

    for &format in util::ALL_FORMATS {
        yml += &format!("{format:?}: >\n");

        let mut add_prop = |prop: &str, value: &str| {
            yml += &format!("  {prop}: {value}\n");
        };

        add_prop("color", &format!("{:?}", format.color()));
        add_prop("pixel", &format!("{:?}", PixelInfo::from(format)));

        let supports_dx10 = Header::new_image(16, 16, format).to_dx10().is_some();
        let supports_dx9 = Header::new_image(16, 16, format).to_dx9().is_some();
        let mut headers = String::new();
        if supports_dx9 {
            headers += "DX9 ";
        }
        if supports_dx10 {
            headers += "DX10";
        }
        add_prop("headers", headers.trim());

        if let Ok(four_cc) = FourCC::try_from(format) {
            add_prop("four_cc", &format!("{four_cc:?}"));
        }
        if let Ok(dxgi) = DxgiFormat::try_from(format) {
            add_prop("dxgi", &format!("{dxgi:?}"));
        }

        add_prop(
            "encoding",
            if format.encoding_support().is_some() {
                "✔️"
            } else {
                "❌"
            },
        );
        if let Some(encoding) = format.encoding_support() {
            add_prop("  split_height", &format!("{:?}", encoding.split_height()));

            add_prop(
                "  dithering",
                &format!(
                    "{:?}{}",
                    encoding.dithering(),
                    if encoding.local_dithering() {
                        " (local)"
                    } else {
                        ""
                    }
                ),
            );

            if let Some((w, h)) = encoding.size_multiple() {
                add_prop("  size_multiple", &format!("{w}x{h}"));
            }
        }

        yml += "\n\n";
    }

    util::TextSnapshot.assert(&util::test_data_dir().join("format-metadata.yml"), &yml);
}

#[test]
fn format_conversion() {
    for &format in util::ALL_FORMATS {
        if format == Format::BC3_UNORM_NORMAL {
            continue;
        }

        if let Ok(dxgi) = DxgiFormat::try_from(format) {
            let roundtrip = Format::from_dxgi(dxgi).unwrap();
            assert_eq!(format, roundtrip, "DXGI -> Format -> DXGI: {format:?}");
        }

        if let Ok(four_cc) = FourCC::try_from(format) {
            let roundtrip = Format::from_four_cc(four_cc).unwrap();
            assert_eq!(format, roundtrip, "FourCC -> Format -> FourCC: {format:?}");
        }
    }
}
